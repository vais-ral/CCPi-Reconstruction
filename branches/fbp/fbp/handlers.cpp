/*$Id: handlers.c 80 2010-02-05 10:28:12Z kny48981 $*/
#ifdef __linux__
#   define _GNU_SOURCE
#include <stdlib.h>
#include <stdio.h>
#include <sys/signal.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <errno.h>
#include <signal.h>
#include <setjmp.h>

#ifdef GNU_TRAP_FPE
#ifndef _GNU_SOURCE
#   define _GNU_SOURCE
#endif /*_GNU_SOURCE*/
#   include <fenv.h>
extern int feenableexcept (int excepts);
#endif /*GNU_TRAP_FPE*/
int the_signo;

/*
   extern int jflg;
   extern jmp_buf env;
   extern int signal_change_freq;
*/

//extern int errno;
extern const char  * const  myname;

void float_action (int signo,siginfo_t * myinfo,void * mycontext)
{                               /* signal handler for sigfpe */
  static int count = 0;
  fprintf(stderr,"signal action code: %i\n",myinfo->si_code);
  fprintf(stderr,"signal action pid: %lx\n",myinfo->si_pid);

  printf ("\nSignal handler: float_action: ERROR: fpe detected (signal %i) !!!!\n", signo);

  count++;
  if (count >= 10){
    printf ("\n%s: More than %i fpe errors detected. Exiting...\n", __func__,count);
    exit (60);
  }
  return;
}
void float_error (int signo)
{                               /* signal handler for sigfpe */
  static int count = 0;


  printf ("\nSignal handler: float_error: ERROR: fpe detected (signal %i) !!!!\n", signo);
  if (count == 0)
  #ifdef JUNK
    printf ("\nRaising USR2 to obtain output step.\n");
  raise (SIGUSR2);
  #endif
  count++;
  if (count >= 10){
    printf ("\n%s: More than %i fpe errors detected. Exiting...\n", __func__,count);
    exit (60);
  }
  signal (SIGFPE, float_error);
  return;
}

void catchit (int signo)
{                               /* signal handler */
  printf ("\n%s: %s: Signal %d received \n",myname,__func__, signo);
  printf ("attempting to flush files ... \n");
  the_signo = signo;
  fflush (NULL);
  sync();
  //FILE *fp;
  //struct stat status;

  /******** handle the TERM signal *************/
  if (signo == SIGTERM){
   printf("%s: got SIGTERM\n",__func__);
   printf ("attempting to close files ... \n");
   fcloseall();
   sync();
   printf ("exiting ... \n");
   exit(199);

  /******** handle the USR1 signal *************/
  } else if (signo == SIGUSR1) {
   /* jflg = JFLG_WRITEXIT; */
   printf("%s: got SIGUSR1\n",__func__);


  /******** handle the USR2 signal *************/
  }else if (signo == SIGUSR2) {
   /*  jflg = JFLG_WRITEBIN; */
    printf("%s: got SIGUSR2\n",__func__);
    signal (SIGUSR2, catchit);

    /********************************************************/
    /* mechanism for changing output timestep while runnign */
    /* if the file is there, then it gets read when the signal */
    /* is caught */

    #ifdef JUNK
    if (stat ("umat_newstep.in", &status) == 0) {
      char *line, *sep, *token;
      line = (char *) calloc (MAX_STRING_LEN, sizeof (char));
      sep = (char *) calloc (MAX_STRING_LEN, sizeof (char));
      sprintf (sep, " ,;\t\n\r");
      fprintf (stderr, "%s: Changing the output step as requested.\n", __func__);

      /* change the time step */
      fp = fopen ("umat_newstep.in", "r");

      while (fgets (line, MAX_STRING_LEN, fp) != NULL) {
        /* ignore comment and blank lines */
        if (line[0] == '%' || line[0] == '#' || (token = strtok (line, sep)) == NULL) {
          continue;
        } else if (strcasecmp (token, "NewStep") == 0) {
          if ((token = strtok (NULL, sep)) != NULL)
            signal_change_freq = atoi (token);
          if (signal_change_freq <= 0) {
            signal_change_freq = 0;
          }
        } else {
          signal_change_freq = 0;
        }
      }
    } else {
      /* no change */
      signal_change_freq = 0;
      fprintf (stderr, "%s:Returning with output flag set.\n", __func__);
    }
    return;
  #endif /*JUNK*/
  }
  //longjmp (env, 1);
  return;
}

#ifdef GNU_TRAP_FPE
void enable_fpe_traps ()
{
  /*
   * This installs the SIGFPE signal handler and enables traps for
   *
   * debugging purposes.
   */

  fenv_t env;
  int excepts;

  /* Enable exception trapping. */

  excepts = FE_DIVBYZERO | FE_INVALID | FE_OVERFLOW;
  feholdexcept (&env);          /* start clean */
  if (feenableexcept (excepts) == -1)
    exit (1);                   /* set traps */
}
#endif

/***************************************************/
/* rcs id routine to include rcs id in the program */
/* generated by make_rcs_sub.sh script             */
/***************************************************/
char const *handlers_c ()
{
  static char const rcsid[] = "$Id: handlers.c 80 2010-02-05 10:28:12Z kny48981 $";

  return (rcsid);
}
#endif /*__linux__*/
